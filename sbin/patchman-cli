#!/usr/bin/env python

import os
import sys
import argparse
import datetime

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "patchman.settings")
from django.conf import settings

from django.core.exceptions import ObjectDoesNotExist

from hosts.models import Host
from packages.models import Package, PackageName, PackageUpdate
from repos.models import Repository
from arch.models import PackageArchitecture, MachineArchitecture
from reports.models import Report
from receivers import print_info_message, print_debug_message, print_error_message
from util import create_pbar, update_pbar

from tagging.models import TaggedItem

force = False
verbose = False


def get_hosts(host=None, action='Performing action'):
    """ Helper function to get a list of hosts
    """

    hosts = []

    if host:
        try:
            hosts.append(Host.objects.get(hostname=host))
            message = '%s for host %s' % (action, host)
        except:
            message = 'Host %s does not exist' % host
    else:
        message = '%s for all hosts' % action
        hosts = Host.objects.all()

    if verbose:
        print message

    return hosts


def get_repos(repo=None, action='Performing action', only_enabled=False):
    """ Helper function to get a list of repos
    """

    repos = []

    if repo:
        try:
            repos.append(Repository.objects.get(id=repo))
            message = '%s for repo %s' % (action, repo)
        except:
            message = 'Repo %s does not exist' % repo
    else:
        message = '%s for all repos' % action
        if only_enabled:
            repos = Repository.objects.filter(enabled=True)
        else:
            repos = Repository.objects.all()

    if verbose:
        print message

    return repos


def update_repos(repo=None):
    """ Update metadata for all enabled repos.
        Specify a repo ID to update a single repo.
    """

    repos = get_repos(repo, 'Updating metadata', True)

    for repo in repos:
        if verbose:
            print '%s' % repo
        repo.update(force)
        if verbose:
            print '\n'


def list_repos(repo=None):
    """ Print info about a list of repositories
        Defaults to all repos
    """

    repos = get_repos(repo, 'Printing information')

    for repo in repos:
        repo_info(repo)


def repo_info(repo):
    """ Print info about a single repo
        If verbose is specified, information about mirrors is also printed
    """

    print '%s : %s' % (repo.id, repo)
    if verbose:
        print 'security: %s  arch: %s' % (repo.security, repo.arch)
        print 'Mirrors:'
        for mirror in repo.mirror_set.all():
            print mirror.url
            print 'last updated: %s    checksum: %s\n' % (mirror.timestamp, mirror.file_checksum)


def clean_packages():
    """ Removes packages that are no longer in use
    """

    packages = Package.objects.filter(mirror__isnull=True, host__isnull=True)
    plen = packages.count()
    if plen == 0:
        if verbose:
            print 'No orphaned packages found.'
    else:
        create_pbar('Removing %s orphaned packages:' % plen, plen)
        for i, o in enumerate(packages):
            p = Package.objects.get(name=o.name, epoch=o.epoch, version=o.version, release=o.release, arch=o.arch, packagetype=o.packagetype)
            p.delete()
            update_pbar(i + 1)


def clean_arches():
    """ Removes architectures that are no longer in use
    """

    parches = PackageArchitecture.objects.filter(package__isnull=True)
    plen = parches.count()

    if plen == 0:
        if verbose:
            print 'No orphaned package architectures found.'
    else:
        create_pbar('Removing %s orphaned p arches:' % plen, plen)
        for i, p in enumerate(parches):
            a = PackageArchitecture.objects.get(name=p.name)
            a.delete()
            update_pbar(i + 1)

    marches = MachineArchitecture.objects.filter(host__isnull=True, repository__isnull=True)
    mlen = marches.count()

    if mlen == 0:
        if verbose:
            print 'No orphaned machine architectures found.'
    else:
        create_pbar('Removing %s orphaned m arches:' % mlen, mlen)
        for i, m in enumerate(marches):
            a = MachineArchitecture.objects.get(name=m.name)
            a.delete()
            update_pbar(i + 1)


def clean_package_names():
    """ Removes package names that are no longer in use
    """

    names = PackageName.objects.filter(package__isnull=True)
    nlen = names.count()

    if nlen == 0:
        if verbose:
            print 'No orphaned package names found.'
    else:
        create_pbar('Removing %s unused package names:' % nlen, nlen)
        for i, packagename in enumerate(names):
            packagename.delete()
            update_pbar(i + 1)


def clean_repos():
    """ Removes repositories that contain no mirrors
    """

    repos = Repository.objects.filter(mirror__isnull=True)
    rlen = repos.count()

    if rlen == 0:
        if verbose:
            print 'No repositories with zero mirrors found.'
    else:
        create_pbar('Removing %s empty repos:' % rlen, rlen)
        for i, repo in enumerate(repos):
            repo.delete()
            update_pbar(i + 1)


def clean_reports(s_host=None):
    """ Delete old reports for all hosts, specify host for a single host.
        Reports with non existent hosts are only removed when no host is specified.
    """

    hosts = get_hosts(s_host, 'Cleaning reports')
    timestamp = datetime.date.today()

    for host in hosts:
        if verbose:
            print host
        host.clean_reports(timestamp)

    if s_host == None:

        reports = Report.objects.filter(accessed__lt=timestamp)
        rlen = reports.count()

        if rlen != 0:
            create_pbar('Removing %s extraneous reports:' % rlen, rlen)
            for i, report in enumerate(reports):
                report.delete()
                update_pbar(i + 1)


def clean_tags():
    """ Delete unused tags
    """

    tagged_items = list(TaggedItem.objects.all())
    to_delete = []

    for t in tagged_items:
        hostid = t.object_id
        try:
            # tags are only used for hosts for now
            host = Host.objects.get(pk=hostid)
        except ObjectDoesNotExist:
            to_delete.append(t)

    tlen = len(to_delete)

    if tlen != 0:
        create_pbar('Removing %s unused tagged items' % tlen, tlen)
        for i, t in enumerate(to_delete):
            t.delete()
            update_pbar(i + 1)


def host_updates(host=None):
    """ Find updates for all hosts, specify host for a single host
    """

    hosts = get_hosts(host, 'Finding updates')

    for host in hosts:
        if verbose:
            print '\n%s' % host
        host.find_updates()


def dns_checks(host=None):
    """ Check all hosts for reverse DNS mismatches, specify host for a single host
    """

    hosts = get_hosts(host, 'Checking rDNS')

    for host in hosts:
        if verbose:
            print '%s:\t' % host.__unicode__()[0:25].ljust(25),
            sys.stdout.softspace = False
        host.check_rdns()


def process_reports(host=None):
    """ Process all pending reports, specify host to process only a single host
        The --force option forces even processed reports to be reprocessed
        No reports are skipped in case some reports contain repo information
        and others only contain package information.
    """

    reports = []
    if host:
        try:
            reports = Report.objects.filter(processed=force, host=host).order_by('created')
            message = 'Processing reports for host %s' % host
        except:
            message = 'No reports exist for host %s' % host
    else:
        message = 'Processing reports for all hosts'
        reports = Report.objects.filter(processed=force).order_by('created')

    if verbose:
        print message

    for report in reports:
        report.process(False)


def clean_updates():
    """ Removes PackageUpdate objects that are no longer
        linked to any hosts
    """

    package_updates = PackageUpdate.objects.all()

    for update in package_updates:
        if update.host_set.count() == 0:
            if verbose:
                print 'Removing unused update %s' % update
            update.delete()
        for duplicate in package_updates:
            if update.oldpackage == duplicate.oldpackage and \
               update.newpackage == duplicate.newpackage and \
               update.security == duplicate.security and \
               update.id != duplicate.id:
                if verbose:
                    print "Removing duplicate update: %s" % (update)
                for host in duplicate.host_set.all():
                    host.updates.remove(duplicate)
                    host.updates.add(update)
                    host.save()
                duplicate.delete()


def dbcheck():
    """ Runs all clean_* functions to check database consistency
    """
    clean_updates()
    clean_packages()
    clean_package_names()
    clean_arches()
    clean_repos()
    clean_updates()
    clean_tags()


def collect_args():

    parser = argparse.ArgumentParser(description='Patchman CLI tool')
    parser.add_argument('-f', '--force', action='store_true',
                help='disregard stored checksums and force-update all repositories')
    parser.add_argument('-q', '--quiet', action='store_true',
                help='less output (e.g. for cronjobs)')
    parser.add_argument('-u', '--update', action='store_true',
                help='update repositories')
    parser.add_argument('-R', '--repo',
                help='only perform action on this repository (repo_id)')
    parser.add_argument('-l', '--list', action='store_true',
                help='list all available repositories and repo_ids')
    parser.add_argument('-U', '--host-updates', action='store_true',
                help='find updates for all hosts')
    parser.add_argument('-H', '--host',
                help='only perform action on this host (fqdn)')
    parser.add_argument('-p', '--process-reports', action='store_true',
                help='process all pending reports')
    parser.add_argument('-r', '--clean-reports', action='store_true',
                help='remove all but the last three reports')
    parser.add_argument('-d', '--dbcheck', action='store_true',
                help='perform some sanity checks and clean unused db entries')
    parser.add_argument('-n', '--dns-checks', action='store_true',
                help='perform reverse DNS checks if enabled for that host')
    parser.add_argument('-a', '--all', action='store_true',
                help='Convenience flag for -u -U -p -r -d -n')
    return parser


def process_args(args):

    showhelp = True
    recheck = False

    if args.all:
        args.process_reports = True
        args.clean_reports = True
        args.update = True
        args.host_updates = True
        args.clean_updates = True
        args.dbcheck = True
        args.dns_checks = True
    if args.list:
        list_repos(args.repo)
        return False
    if args.process_reports:
        process_reports(args.host)
        showhelp = False
    if args.clean_reports:
        clean_reports(args.host)
        showhelp = False
    if args.dbcheck:
        dbcheck()
        showhelp = False
    if args.update:
        update_repos(args.repo)
        showhelp = False
        recheck = True
    if args.host_updates:
        host_updates(args.host)
        showhelp = False
        recheck = True
    if args.dbcheck and recheck:
        dbcheck()
    if args.dns_checks:
        dns_checks(args.host)
        showhelp = False
    return showhelp


if __name__ == '__main__':

    parser = collect_args()
    args = parser.parse_args()

    settings.FORCE = args.force
    settings.VERBOSE = not args.quiet

    force = args.force
    verbose = not args.quiet

    showhelp = process_args(args)

    if showhelp:
        parser.print_help()
